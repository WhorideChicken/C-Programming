/*포인터 -3
* 포인터 뎃셈
* 포인터 주소 자체에 +1을 더하면 
* 주고값에 4가 더해진다 int* 이기 때문에 int는 4바이트 이므로 4가 더해집니다.
* char는 1바이트, double은 8바이트
* 왜 포인터가 가리키는 형의 크기만큼 더할까?
* *pa와 *pb가 있다고 가정할 때
* C언어에서 pa + pb등의 포인터끼리의 덧셈은 허용하지 않는다.
* 포인터끼리의 덧셈은 아무런 의미가 없고(주소값 + 주소값이기 떄문에 아무런 연관없는 임의 주소를 바라보게 된다.)
* 하지만 포인터끼리 뺄셈은 가능하다 : 이유는 추후
* 
* 두번 째 * *pa와 *pb가 있다고 가정할 때
* pb = pa가 가능하여
* 같이 *pa, *pb를 출력하면 같은 값을 출력합니다.(자료형이 다르면 형변환을 해주어야한다.)
* 
* 배열과 포인터
* 
* 배열의 특성상 배열들의 각 원소는 메모리 상에 연속되게 놓입니다.
* 10개의 배열을 선언 후 각각 원소의 주소값을 찍으면 자료형읜 크기만큼 주소값이 차이가난다.
* ex int형 해별이면 4바이트씩
* 즉 포인터를 활용하게 되면 포인터 주소에 1씩 더하면 다음 원소를 가르키게 됩니다. 2를 더하면 다다음 원소를
* 배열 자체를 출력하면 해당 배열의 0번쨰 인자의 주소를 알려준다.
* int arr[3]
* printf(arr) => arr[0]의 주소
* printf(arr) == printf(&arr[0]
* 그렇다해서 배열의 이름은 배열의 첫번째 원소를 가리키는 포인터는 아닙니다.
* 배열은 배열이고 포인터는 포인터다 
* C언어 상에서 배열의 이름이 sizeof 연산자나 주고값 연산자(&)와 사용 될 때 경우를 빼고
* 배열의 이름을 사용시 암묵적으로 C언어가 첫번째 원소를 가리키는 포인터로 타입을 변환 시킵니다.
* 
* 
* [] 연산자의 역할
* arr[3]과 3[arr]은 같은 값을 출력한다
* 3[arr]은 가독성이 떨어지기 때문에 대부분의 프로그래머들은 arr[3]을 사용할것이다.
* int* arr[3]; 은 포인터 주소를 담는 배열을 만들라는 뜻
* 
*/
