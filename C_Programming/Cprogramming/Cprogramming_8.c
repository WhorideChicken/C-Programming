/*포인터 -4
* 
* 배열은 배열이고 포인터는 포인터다
* sizeof나 & 연산자를 사용하는 경우를 제외하면 배열의 이름은 첫번 째 원소를 가리킨다.
* arr[i]와 같은 문장은 사실 컴파일러에 의해 *(arr+i)로 변환된다.
* 
* 1차원 배열 가리키기
* 
*/

#include <stdio.h>
void PointerExample();
void DoublePointer();
void ArrayPointrerExample();
void ArrayPointrerExampleTwo();

int main()
{
	ArrayPointrerExampleTwo();
	return 0;
}

void PointerExample()
{
	int arr[3] = { 1,2,3 };
	int* parr;

	parr = arr;
	/*parr = &arr[0]과 같은것*/
	//parr++을하면 int 4바이트만큼 다음 주소를 가르키게 되도 다음 원소를 가르킨다.
	//그렇가면 arr만 사용하면 첫번째 주소를 변환하여 갖는다했는데
	//arr++이 가능할까?
	//-> 이문장은 단순 배열의 첫번째 원소를 가리키는 주고값 자체가 될뿐이라 (주소)++; 가 되므로 오류가 납니다.
	printf("%d\n", arr[1]);
	printf("%d\n", parr[1]);
	printf("%d\n", *parr);
}

/* 포인터의 포인터
* 포인터를 가르키는 포인터
* pa는 a의 주고값을 가르키고 ppa는 pa의 주소를 가르킨다.
* *pa는 a의 값을 가르키고 *ppa는 pa의 주소를 가르킨다 => **ppa는 결국 *(*ppa)가 되므로 a를 지칭하게 된다.
*/

void DoublePointer()
{
	int a;
	int* pa;
	int** ppa;

	pa = &a;
	ppa = &pa;
	
	a = 3;

	printf("----------------\n");
	printf("%d\n", a);
	printf("%d\n", *pa);
	printf("%d\n", **ppa);
	printf("----------------\n");

	printf("----------------\n");
	printf("%p\n", &a);
	printf("%p\n", pa);
	printf("%p\n", *ppa);
	printf("----------------\n");

	printf("----------------\n");
	printf("%p\n", &pa);
	printf("%p\n", ppa);
	printf("----------------\n");

}

/*
* 배열 이름의 주소값
* 배열은 C언어에서 sizeof, &연산자를 사용 할 떄 빼고 전부다 포인터로 암묵적으로 변환이 이뤄진다했습니다.
* 그렇다면 주소값 연사자를 사용하는 방법을 배워보자
*/

void ArrayPointrerExample()
{
	int arr[3] = { 1,2,3 };
	int* parrR = &arr;
	int(*parr)[3] = &arr;
	/*&arr은 무슨 의미일까? 
	* arr이 크기가 3인 배열이기 때문에 &arr을 보관할 포인터의 크기는 크기가 3인 배열을 가리키는 포인터가 되어야한다.
	* (*parr)[3] -> 꼭 ()로 감싸야한다. ()를 빼버리면 int *parr[3]으로 주소값 3개를 갖는 포인터 배열로 인식한다.
	parr과 arr은 같은 값을 가집니다.
	(*parr)에 arr주소를 넣었기 때문에 모두 배열의 첫 번째 원소의 주소값을 출력한다.
	int(*parr)[3]은 3크기의 int 배열을 가르킨다는 뜻
	*
	* C언어는 B 언어에서 파생된 언어입니다 B언어에서는 실제 배열이 있고 배열을 가리키는 포인터가 따로 있었습니다.
	* 즉 arr과 arr[0]은 각각 다른 메모리를 차지했습니다 C언어에서는 arr은 실제 메모리에 있지 않고 arr[0]의 주소입니다
	* 때문에 B언어에서는 arr과 arr[0]은 다른 값을 출력했었고 데니스 리치는 B문법을 계승하되 이와 찾이 포인터 공간을
	* 낭비하지 않으려 했습니다. 그래서 조금 이상하지만 메모리 공간을 효율적으로 쓰게 되는 배열-포인터 관계가 탄생했습니다.
	*/ 

	printf("%d\n", arr[1]);
	printf("%d\n", (*parr)[1]);
	printf("%d\n", *parrR+1);
}

/*
* 2차원 배열의 [] 연산자
* int a[2][3]은 컴퓨터 메모리상 a[0][0]. a[0][1] ~ a[2][3]이 연속적으로 존재하게 됩니다.
* 2차원 배열이라해서 메모리에 2차원으로 존재하는것이 아닌 연속적으로 존재합니다.
*/

void ArrayPointrerExampleTwo()
{
	int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };

	printf("%p\n", arr);
	printf("%p\n", arr[0]);
	printf("%p\n", &arr[0]);
	printf("%p\n", &arr[0][0]);

	printf("%p\n", arr[1]);
	printf("%p\n", &arr[1][0]);

	/*arr[0]과 arr[0][0]의 주소값이 같고 arr[1], arr[1][0]의 주소값이 같습니다.
	* 기존 1차원 배열과 마찬가지로 sizeof나 & 연산자를 사용하지 않은 경우 arr[0]은 arr[0][0]을
	* 가르키는 포인터로 타입 변환이 되고 arr[1]도 마찬가지로 arr[1][0]을 가리키는 포인터로 타입이 변환 되는걸 볼 수 있습니다.
	*
	* 1차원 배열에서 arr과 &arr[0]은 그 자체로는 완전히 다른것인것 처럼 2차원 배열 arr[0]과 arr[0][0]은 다릅니다.
	* 암묵적으로 타입 젼환시에 같은것으로 변할 뿐입니다.
	* 따라서 sizeof를 활용해 2차원 배열의 열과 행의 개수를 알 수 있습니다.
	*/

	printf("열 %d\n", sizeof(arr[0]) / sizeof(int));
	printf("행 %d\n", sizeof(arr) / sizeof(arr[0]));

	/*2차원 배열의 이름을 포인터에 전달하기 위해선 해당 포인터의 타입은 뭐가 될까요?
	* arr[0]은 int*가 보관 할 수 있으니 arr은 int** 이어야할까요?
	* 정답은 아니오 입니다.
	*
	* int** 포인터가 배열의 이름을 가리킨다면 배열의 원소에 자유롭게 접근 할 수 있어야 할겁니다.
	*/

	//잘못 된 코드
	int** parr = arr;
	printf("%d\n", parr[1][1]);

	/*
	* int arr[a][b]라고 정의된 2차원 배열을 생각하면
	* int arr[a][b]는 int arr[b] 크기 배열이 메모리에 a개가 존재하는것이라 생각하면 됩니다.
	* arr[x][0]의 주소값은 x번째 int arr[b]짜리; 배열이 될겁니다.
	*
	* 따라서 2차원 배열을 가리키는 포인터를 통해서 원소들을 정확히 접근하기 위해서는
	* 1. 가리키는 원소의 크기
	* 2. b의 값
	* 위의 두 정보가 포인터의 타입에 명시 되어 있어야 컴파일러가 원소를 올바르게 접근 할 수 있습니다.
	*/

	int(*nParr)[3];
	nParr = arr;
	printf("%d\n", arr[1][2]);
	printf("%d\n", nParr[1][2]);

	/*위의 코드 처럼 2차원 배열을 가리키는 포인터의 배열의 크기에 대한 정보다 있어야합니다.
	* (배열의 자료형)(*포인터이름)(2차원 배열의 열의 개수)
	* int (*parr)[3];은 int형의 3열짜리 2차 배열 원소에 접근할 수 있습니다.
	* parr은 크기가 3짜리 1차원 배열을 가리키는 포인터를 의미합니다.
	* nParr을 2차원 배열을 가르키게 하고 싶으면 뒤에 열이 3개짜리 2차원 배열을 할당하면 됩니다
	* 3이 아닌 다른 크기의 배열을 할당하면 오류가 발생합니다.
	*/

	int** parr = arr;
	printf("%d\n", *(parr + 1));
	/*
	* 위의 코드에서는 무슨일을 한것일까요?
	* parr에는 arr 주소값이 들어있기는 합니다
	* parr[1][1]은 *(*(parr+1)+1)과 동일한 문장이 됩니다.
	* 포인터의 크기는 시스템 아키텍처에 따라 결정됩니다.
	* 프로그램이 64비트 시스템에서 실행되고 있으면 64비트 시스템에서느 ㄴ메모리 주소를 나타내기 위해
	* 64비트를 사용하며, 이는 포인터 크기를 8바이트로 만듭니다. 32비트 시스템에서는 포인터가 4바이트입니다.
	* int* 크기는 시스템의 아키텍처에 따라 달라집니다.(int뿐 아니라 float, doble 등 포인터의 크기는 8바이트입니다.)
	* 
	* 다시 이어서 설명 드리자면 parr은int*를 가리키는 포인터고 int*8바이트입니다. int*에 +1을 했기 때문에
	* 즉 parr+1은 8바이트(int는 4바이트이므로 2만큼 증가)+1 세번째 원소의 주소값을 가지게 됩니다.
	* 따라서 *(parr+1)은 3이 됩니다. 또한 parr+1의 타입은 int*입니다 따라서 int의 크기만큼인 4가 늘어나
	* *(parr+1)+1은 7이 됩니다. 주소값 7에 있는 값을 읽어라 하는 말이 되므로 오류가 발생합니다.
	* 
	* * parr[1][1]이 *(*parr+1)+1)이 되는 과정
	* parr은 2차원 배열 첫번째 행의 시작 주소입니다.
	* parr + i는 i번째 행의 시작 주소를 가리킵니다.
	* *(parr + i)는 i번째행의 시작 주소 값을 가리킵니다.
	* *(parr + i) + j는 i번째 행의 j번째 요소의 값을 가리킵니다.
	* 즉 parr[1][1]은 *(parr+1)+1로 표현됩니다.
	*/
}

/*포인터 배열
* 포인터 배열은 말 그대로 포인터들의 배열입니다.
* 포인터들을 모아놓은 배열들입니다.
* int *arr[3]
* int를 가리키는 포인터들이 모여있는 3크기의 배열
* arr[0]~arr[2]은 각각 자신들이 각각 본인들이 가리키는 주소값들이 들어갑니다.
*/
